---
layout:     post
title:      CAS无锁算法
category:   JUC
tags:   [Java, JUC]
---
#### 乐观锁和悲观锁
- 独占锁是一种悲观锁，synchronized就是一种独占锁，它假设最坏的情况，并且只有在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。  
- 乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。  
**CAS**是一个典型的乐观锁的算法

#### 原理
CAS算法（compare and swap）是保持操作原子性的一个重要的算法。  
CAS算法有三个值 当前主存的实际值V、预估值A、待写入值B  
当  V == A 时 ，V = B。否则本次操作失败，该线程尝试重新操作

我们以i++为例子：i++分别一下几个步骤，
- 从内存读i值 
- 在cpu中计算i变为1
- 将i=1写回到内存    
  
现在有两个线程执行 i++ ，的操作：
-  线程1，读取预估值A=0 ，计算后B = 1，此时 要将B的值写回，查看当前内存中的值V =0 ，V == A， 将V = B =1 写入成功  
-  线程2，读取预估值A=0 ，计算后B = 1，此时 要将B的值写回，查看当前内存中的值V =1（已经被线程1修改） ，V != A，失败，只能重新尝试   
CAS算法每次保证只有一个线程能够操作成功，操作失败的线程重新进行尝试，这中间没有挂起，没有锁的上下文切换等，速度会快很多  
  