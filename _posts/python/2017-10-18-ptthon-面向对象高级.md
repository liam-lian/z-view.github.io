---
layout:     post
title:      面向对象-高级
date:  2017-10-18
category:   面向对象
tags:   [python,面向对象]
---
动态语言
---
当我们定义了一个class，创建了一个class 的实例后，我
们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。  
```
>>> s = Student()
>>> s.name = 'Michael' # 动态给实例绑定一个属性

>>> def set_age(self, age): # 定义一个函数作为实例方法
... self.age = age
...
>>> from types import MethodType
>>> s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
>>> s.set_age(25) # 调用实例方法

>>> Student.set_score = MethodType(set_score, Student) #给class 绑定方法后，所有实例均可调用
```

\_\_slots\_\_
---
限制添加的属性，不能随意的添加属性，只能添加我需要的属性
```
class Student(object):
  __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
```
使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对
继承的子类是不起作用的，除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自
身的__slots__加上父类的__slots__

@property
---
```
class Student(object):
@property
def birth(self):
return self._birth
@birth.setter
def birth(self, value):
self._birth = value
@property
def age(self):
return 2015 - self._birth
```
多继承
---
python支持多继承  
```
class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
pass
```
由于Python 允许使用多重继承，因此，MixIn 就是一种常见的设计。
只允许单一继承的语言（如Java）不能使用MixIn 的设计  

定制类
---
- `__str__()` 类似于toString，在print的时候调用
- `__repr__()` 与str一样，但是一个是给开发者看的，在调试的时候输出
- `__iter__()`  
如果一个类想被用于for ... in循环，类似list 或tuple 那样，就必须实
现一个`__iter__()`方法，该方法返回一个迭代对象，然后，Python 的for
循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值
```
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b
    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己,因为下面定义了__next__()方法，所以这个类本身也是一个迭代器
    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a > 100000: # 退出循环的条件
            raise StopIteration();
        return self.a # 返回下一个值
```
- `__getitem__(self,n)`
像list 那样按照下标取出元素    
比如：写出一个类，类中的第i个元素就是0-i的和
```
class mysum(object):
    def __getitem__(self, item):
        if (isinstance(item,int)):
            z=0
            for i in range(item+1):
               z=z+i
            return z
        if(isinstance(item,slice)):
            start=item.start
            if(start==None):
                start=0
            z=0
            for i in range(start,item.stop+1):
                z=z+i
            return z
su=mysum();
print(su[10])
print(su[1:3])
```
- `__getattr__()`
正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错  
在没有找到属性的情况下，调用__getattr__，已有的属性，不会在__getattr__中查找

- `__call__()`
说明这个类是可以调用的，当直接调用类对象的时候，实际上就是调用的这个函数  
```
class mysum(object):
    def __call__(self, *args, **kwargs):
        print("call==")
su=mysum();
su()
```
通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。  
```
>>> callable(mysum())
True
>>> callable(max)
True
>>> callable([1, 2, 3])
False
```


