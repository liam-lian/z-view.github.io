---
layout:     post
title:      NIO-buffer进阶
date:  2017-11-25
keywords:   NIO
category:   java
tags:   [Java,NIO]
---
#### 创建Buffer
```
1. ByteBuffer buffer = ByteBuffer.allocate( 1024 );
2. byte array[] = new byte[1024];
   ByteBuffer buffer = ByteBuffer.wrap( array );
```
#### 缓冲区分片
slice() 方法根据现有的缓冲区创建一种 子缓冲区 。也就是说，它创建一个新的缓冲区，新缓冲区与原来的缓冲区的一部分共享数据。  
缓冲区片对于促进抽象非常有帮助。可以编写自己的函数处理整个缓冲区，而如果想要将这个过程应用于子缓冲区上  
只需取主缓冲区的一个片，并将它传递给您的函数。这比编写自己的函数来取额外的参数以指定要对缓冲区的哪一部分进行操作更容易。  
就是说分片产生一个子缓冲区，他和原来的Buffer公用底层的数组。子缓冲区就是原来的Buffer的position和limit中间的那一段
```
    int b[]={1,2,3,4,5,6,7,8};
    IntBuffer intBuffer=IntBuffer.wrap(b);
    intBuffer.position(3);
    intBuffer.limit(5);
    IntBuffer sliceIntBuffer=intBuffer.slice();

    for (int i = 0; i < sliceIntBuffer.limit(); i++) {
        sliceIntBuffer.put(i,sliceIntBuffer.get(i)*10);
    }

    int []res=intBuffer.array();
    for (int i:res)
        System.out.println(i);
```
#####  只读缓冲区
通过调用缓冲区的 asReadOnlyBuffer() 方法，将任何常规缓冲区转换为只读缓冲区，  
这个方法返回一个与原缓冲区完全相同的缓冲区(**并与其共享数据**)，只不过它是只读的。