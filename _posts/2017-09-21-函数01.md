---
layout:     post
title:      python-函数01
date:  2017-09-21
category:   python基础
tags:   [python,python基础]
---
### 默认参数
###   可变参数
### 关键字参数
### 命名关键字参数
关键字参数的名字可以随便起，使用命名关键字参数可以把参数的名字限定一下
```
def person(name, age, *, city=‘BJ’, job):
     print(name, age, city, job)
```
这样传入的关键字参数只能是city=？？ job=？？ 这种形式  
参数定义的顺序必须是：必选参数、默认参数、可变参数/命名关键字参数和关键字参数


### 函数式编程
函数名其实就是指向函数的变量  
例如：把abs指向10后，就无法通过abs(-10)调用该函数了！因为abs这个变
量已经不指向求绝对值函数而是指向一个整数10！  

### 函数作为返回值 & 闭包
```
def lazy_sum(*args):
   def sum():
     ax = 0
     for n in args:
          ax = ax + n
     return ax
   return sum
```
调用lazy_sum的时候实际上返回的是一个函数，要想得到这个函数（sum函数）的值，需要调用他。  
当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包“  
注意当我们调用lazy_sum()时，每次调用都会返回一个新的函数  
返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。  


### 装饰器
函数本身也是一个对象，我们为函数增加新的功能的时候，可以不去改变函数本身的内容，而是使用装饰器对函数进行增强，这个跟面向切面编程有点像

####  基本装饰器
```
def zsq(func):
    def wapper(*args):
        print('我在传入的函数执行之前做一些操作',args)
        func()  # 执行函数
        print('我在目标函数执行后再做一些事情',args)
    return wapper
    这个装饰器返回看内部的函数，调用的时候使用方法：func=zsq(func)
    这样返回的还是一个函数，也就是说func变成了一个新的函数（wapper），
    后面在执行func的时候，指向的就是一个wapper的函数对象，变相的增加了func的功能.
    ==>调用 func(1,2,3)==>wapper(1,2,3)
```
#### 带参数的装饰器
```
def zsq(*args):
    def wapper(func):
        print('我在传入的函数执行之前做一些操作',args)
        func()  # 执行函数
        print('我在目标函数执行后再做一些事情',args)
    return wapper
    与上面类似，方法是：func=zsq(1,2,3)(func)
    这里就出现问题了，这样定义了之后就直接执行了，最终func=None
    因为zsq(1,2,3)返回函数wapper，wapper(func)随即被调用
```
正确的使用方式如下
```
def zsq(*args):
    def wapper(func):
        def innerwapper(* args_func):
            print('我在传入的函数执行之前做一些操作',args)
            func()  # 执行函数
            print('我在目标函数执行后再做一些事情',args)
        return innerwapper    
    return wapper
这样方法就变成了func=zsq(1,2,3)(func)
第一步返回wapper对象，wapper(func)之后返回innerwapper对象，
实际上最后func指向的就是innermapper对象
```
#### 关于装饰器的语法糖
像上面那样，每次还要包装  func=zsq(func)不方便，python提供了如下的语法：
```
@zsq
def func(*args):
  pass
这个就等价于func=zsq(func)
@zsq(1,2,3)
def func(*args):
  pass
这个就等价于func=zsq(1,2,3)(func)
```
#### 装饰器陷阱
函数被装饰之后，相当于指向了另外一个函数，例如__name__属性的值不是原来的'func'，而是变成了'wapper'  
这经常会带来麻烦，使用functools里面的 @functools.wraps解决问题
  ```
  def zsq(func):
    @functools.wraps(func)
    def wapper(*args):
        print('我在传入的函数执行之前做一些操作',args)
        func()  # 执行函数
        print('我在目标函数执行后再做一些事情',args)
    return wapper
  ```
#### 多个装饰器
面对多个装饰起怎么办？例子：
```
@zsq1
@zsq2
def func(*args)
    pass
```
相当于 func=zsq2(zsq1(func))
就是把后来的装饰器的返回的函数，作为前面的装饰器的参数。







